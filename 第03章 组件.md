# 组件基础

```tsx
import { type Component, type JSX } from "solid-js";

const Profile: Component<{ username: string; phone: string; children: JSX.Element }> = (props) => {
  console.log(props);
  return (
    <div>
      <div>{props.username}</div>
      <div>{props.phone}</div>
      <div>{props.children}</div>
    </div>
  );
};

export default Profile;

```

# 样式

Solid 支持类和样式属性来定义样式。

## 行内样式

```jsx
// String
<div style="color: red; font-size: 16px;">This is a red div</div>

// Object
<div style={{ color: "red", "font-size": "16px" }}>This is a red div</div>
```

> 提示：在 Solid 中，适用对象设置样式时，如果有多个单词适用连字符个改，和React小驼峰命名有所区别。

## 类名样式

1）**动态样式**

动态样式提供了一种基于状态或其他因素（例如用户输入）更改组件外观的方法。这对于创建可以适应不同方案的组件很有用，而无需创建相同组件的多个版本：

```jsx
const [theme, setTheme] = createSignal("light");

<div class={theme() === "light" ? "light-theme" : "dark-theme"}>
  This div's theme is determined dynamically!
</div>;
```

Props 是改变样式的另一种方法。通过将 Props 传递给组件，您可以根据组件的用法或收到的数据调整样式：

```jsx
function ThemedButton(props) {
  return (
    <button class={props.theme}>
      {props.theme === "light" ? "Light Button" : "Dark Button"}
    </button>
  );
}
```

2）**classList**

当你需要给一个元素添加多个 CSS 类时，可以用 `classList`属性来操作。具体用法有两种：

1. **直接传字符串**：比如 `"class1 class2"`一次性添加多个类；
2. **传对象**（更灵活）：对象的键名是类名，键值是布尔值。当值为 `true`时添加该类，`false`时移除该类。

```jsx
// 字符串写法
element.classList.add("active", "highlight"); 

// 对象写法（动态控制）
element.classList.toggle("error", hasError); // hasError为true时添加类，false时移除
```

# 事件处理

Solid 提供了两种将事件听众添加到浏览器的方法：

- `on:__`：将事件侦听器添加到元素中。这也称为本地事件。
- `on__`：将事件侦听器添加到文档中，然后将其分配到元素中。这可以称为委派事件。

代码示例：

```jsx
// 委派事件（合成事件）
<button onClick={handleClick}>Click me</button>

// 原生事件
<div on:scroll={handleScroll}>... very long text ...</div>
```

绑定参数：

```jsx
const handler = (data, event) => {
  console.log("Data:", data, "Event:", event);
};

<button onClick={[handler, "Hello!"]}>Click Me</button>;
```

动态绑定：

```jsx
<div onClick={() => props.handleClick?.()} />
```

### 事件委托

Solid 并未将事件监听器附加到每个单独的元素上，而是通过 `on__` 形式采用合成事件委派方法。在该方法中，事件监听器被附加到文档元素上，并在事件冒泡上升时将其分发给相关的元素。

这一点其实就是 React 中的合成事件。

如果需要将事件监听器附加到 Solid 的事件委派所不支持的元素上，例如自定义元素中的自定义事件，则可以使用 `on:__`。

```jsx
<div on:customEvent={handleCustomEvent} />
```

> **提示**：[Solid 支持的委派事件列表 ↪ ](https://docs.solidjs.com/concepts/components/event-handlers#list-of-delegated-events)

# Props

Props 将状态从父组件传递到子组件的一种方式。这些仅读取的属性将作为JSX中的属性传递给组件，并且可以通过Props对象在组件中访问：

```tsx
function App() {
  // Passing a prop named "name" to the MyComponent component
  return (
    <div>
      <MyComponent name="Ryan Carniato" />
    </div>
  );
}
```

在子组件中通过 **props** 对象访问父组件传递过来的属性：

```tsx
function MyComponent(props) {
  return <div>Hello {props.name}</div>;
}
```

## mergeProps

mergeProps是一个Solid实用函数，旨在将多个可能具有响应性的对象合并在一起。它的行为类似于`object.assign`，但会保留被合并的属性所具有的响应性。这有助于确保在合并对象中的单个属性发生变化时，其响应性不会被丢失。

```tsx
// default props
props = mergeProps({ name: "Smith" }, props)

// clone props
newProps = mergeProps(props)

// merge props
props = mergeProps(props, otherProps)
```

在合并属性时，如果某个属性没有已有的值，那么将使用第一个对象中的值。然而，如果已有值，那么这个已有值将被使用，同时该属性的响应性将得到保留。

## 解构 Props

属性是只读的，这样子组件就不会直接修改父组件传递的数据。Solid 使用单向数据流，这是一种促进更可预测的数据管理的常见模式。

在Solid中，不建议使用解构属性，因为这可能会破坏响应性。相反，您应直接从props`对象中访问属性，或将它们包裹在函数中以确保它们始终是最新的：

```tsx
function MyComponent(props) {
  const { name } = props; // ❌: 打破反应性，当Prop值更改时不会更新
  const name = props.name; // ❌: 破裂反应性的另一个例子
  const name = () => props.name; // ✅: 过将`props.name`纳入函数中，'name（）`始终检索其当前值
}
```

### splitProps

在 SolidJS 中，`splitProps` 是一个用于 **安全解构组件 props 并保持响应性** 的工具函数。

SolidJS 的 props 是响应式代理对象，直接解构（如 `const { a, b } = props`）会丢失响应性。`splitProps`允许你将 props 按需分组，同时保持各组属性的响应式追踪

基本用法：

```tsx
import { splitProps } from 'solid-js';

const [group1, group2, ...rest] = splitProps(props, ["key1", "key2"], ["key3"]);
```

- 参数：

  - `props`：原始 props 对象。

  - 后续参数为键名数组，指定需要分组的属性。

- 返回值：数组，依次对应每组键名的 props 对象，最后一个是剩余属性对象。

`splitProps`内部通过代理（Proxy）为每组属性创建新的响应式对象，确保属性访问仍能被 SolidJS 的依赖收集系统追踪

**场景1：分离特定属性**

```tsx
function Child(props) {
  const [local, others] = splitProps(props, ["greeting", "name"]);
  return (
    <div {...others}>
      <h1>{local.greeting}, {local.name}!</h1>
    </div>
  );
}
```

`local`包含 `greeting`和 `name`，`others`包含剩余属性。

**场景 2：多级分组**

```tsx
const [uiProps, dataProps, rest] = splitProps(
  props,
  ["size", "color"],
  ["id", "value"]
);
```

将 props 分为 UI 相关属性、数据属性和其他属性。

## 将属性传递给子组件

在大多数情况下，仅仅在JSX中使用 `props` 就没有任何问题。然而，在某些情况下，多次访问 `props.children`可能会引入问题并导致意外行为，例如重复创建子组件或元素。对于此类情况，Solid提供了一个 `children` 助手，以确保您始终获得正确的子组件，而不会发生任何意外情况。

```tsx
import { children } from "solid-js";

function ColoredList(props) {
  const safeChildren = children(() => props.children);

  return <>{safeChildren()}</>;
}
```

## 属性透传

属性透传是指通过多层组件传递属性的过程。虽然这种模式有一定用处，但也可能引发问题。当组件嵌套层级较深时，逐层传递属性会变得难以管理。此外，这可能导致组件接收到它们不需要的属性、不必要的重新渲染以及重构困难。

由于 Solid 中的组件不持有状态，因此不需要通过属性在组件间传递状态（但仍可能使用）。正因如此，有时仍需通过多层组件传递属性。常见的解决方案是使用 Context（上下文）将状态传递给深层嵌套的组件，而无需经过中间每一层组件的属性传递。







