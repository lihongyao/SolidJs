@See https://docs.solidjs.com/guides/state-management

# 概述

状态管理是指对影响网络应用程序行为和呈现效果的数据进行处理和操作的过程。为了构建交互式和动态的网络应用程序，状态管理是开发过程中至关重要的一环。在 Solid 中，状态管理是通过使用响应式基本元素来实现的。

我们将通过一个简单的示例来展示这些状态管理概念：

```tsx
import { createSignal } from "solid-js";

export default function Counter() {
  const [count, setCount] = createSignal(0);
  const increment = () => setCount((prev) => prev + 1);

  return (
    <div>
      <span>Count: {count()}</span> {/* Updates when `count` changes */}
      <button type="button" onClick={increment}>
        Increment
      </button>
    </div>
  );
}
```

状态管理包含三个要素：

1. **State（`count`）**：用于确定向用户展示何种内容的数据
2. **View（`<div>{count()}</div>`）**：向用户展示的状态的可视化呈现形式
3. **Actions（`increment`）**：任何能够改变状态的事件

这些元素协同作用，形成了“单向数据流”。当操作改变状态时，视图会更新以向用户展示当前状态。单向数据流简化了数据管理和用户交互的管理，从而为应用程序提供了更可预测和更易于维护的特性。

# 基础状态管理

状态（State）是应用程序的数据源，决定着向用户展示的内容。在Solid中，状态通过**信号（Signal）**这一响应式单元来实现，它既能管理数据状态，又能在数据变更时通知UI更新。

1）**创建状态**

使用 `createSignal` 函数初始化状态值：

```tsx
import { createSignal } from "solid-js";

const [count, setCount] = createSignal(0); // 初始化计数器
```

2）**读取状态**

通过getter函数获取当前值：

```js
console.log(count()); // 输出当前值 → 0
```

3）**更新状态**

通过setter函数修改状态（支持函数式更新）：

```js
setCount(prev => prev + 1); // 递增计数器
console.log(count()); // 输出更新值 → 1
```

# 在UI中渲染状态

要实现动态用户界面，UI必须能实时反映数据状态的变化。JSX作为状态的视觉呈现载体，通过其内置的追踪作用域（tracking scope）保持视图与状态的同步。

状态渲染示例：

```jsx
return (
  <>
    <div>当前计数: {count()}</div>
    <button onClick={increment}>增加</button>
  </>
)
```

为了呈现计数器的当前状态，使用了 JSX 表达式 `{count()}` 。花括号表示该表达式是一个 JavaScript 表达式，圆括号表示这是一个函数调用。此表达式代表了计数器的获取函数，并将获取当前状态值。当状态更新时，用户界面将重新渲染以反映新的状态值。

在 Solid 中，**组件在初始化时只会运行一次**。在这一初始渲染之后，如果状态有任何变化，那么只会更新与信号变化直接相关的 DOM 部分。

能够仅更新 DOM 中的相关部分是 Solid 的一个关键特性，它使得用户界面的更新既高效又流畅。这被称为 **细粒度响应式**。通过减少整个组件或更大范围 DOM 片段的重新渲染，用户界面将保持更高的效率和响应性。

# 响应状态变化

当状态更新时，除了自动更新UI外，有时还需要执行额外的操作。

例如，在“计数器”组件中，您可能希望向用户展示计数值的两倍。这可以通过使用 **Effect** 来实现，Effect 是一种具有响应性的基本元素，当状态发生变化时会执行副作用操作：

```tsx
import { createSignal, createEffect } from "solid-js";

function Counter() {
  const [count, setCount] = createSignal(0);
  const [doubleCount, setDoubleCount] = createSignal(0); // 派生状态

  const increment = () => setCount((prev) => prev + 1);

  // 自动同步派生状态
  createEffect(() => {
    setDoubleCount(count() * 2);
  });

  return (
    <>
      <div>当前计数: {count()}</div>
      <div>翻倍计数: {doubleCount()}</div>
      <button onClick={increment}>增加</button>
    </>
  );
}
```

核心机制解析：

1. 副作用触发

   - `createEffect` 自动检测其内部使用的信号（如 `count()` ）
   - 当 `count` 变化时，自动重新执行副作用函数

2. 派生状态管理

   - 示例中将计算逻辑封装在effect中

   - 实际上更推荐使用`createMemo`优化计算：

     ```
     const doubleCount = createMemo(() => count() * 2);
     ```

3. 性能特征

   - 仅当 `count` 实际变化时才会更新 `doubleCount`
   - 与React不同，不会引起组件函数整体重执行

**类比传统方案**

| 方案       | 更新粒度       | 计算触发方式   | 适用场景       |
| :--------- | :------------- | :------------- | :------------- |
| Effect     | 精确到具体信号 | 依赖变化时触发 | 有副作用的场景 |
| Memo       | 计算结果级别   | 输入变化时触发 | 纯计算场景     |
| 组件重渲染 | 整个组件       | 状态变化时触发 | 传统框架方式   |

# 派生状态管理

## 基础派生方案

```js
const [count] = createSignal(0)
// 简单派生函数（每次调用重新计算）
const doubleCount = () => count() * 2
```

**问题**：在多次调用时会造成重复计算

## 优化方案（createMemo）

```jsx
const doubleCount = createMemo(() => {
  console.log('计算触发')
  return count() * 2
})
```

优势：

- 自动缓存计算结果
- 仅当`count`变化时重新计算
- 多次访问只计算一次

## 完整示例对比

```jsx
import { createMemo, createSignal } from "solid-js";

export default function Counter() {
  const [count, setCount] = createSignal(0);

  // 普通派生函数
  const doubleCount = () => {
    console.log("普通派生调用");
    return count() * 2;
  };

  // 记忆化派生
  const memoizedDouble = createMemo(() => {
    console.log("记忆化计算");
    return count() * 2;
  });

  return (
    <>
      <button onClick={() => setCount((c) => c + 1)}>+1</button>
      <div>普通派生1: {doubleCount()}</div>
      <div>普通派生2: {doubleCount()}</div>

      <div>记忆化派生1: {memoizedDouble()}</div>
      <div>记忆化派生2: {memoizedDouble()}</div>
    </>
  );
}
```

性能对比：

| 方案         | 计算时机       | 重复调用开销   | 适用场景          |
| :----------- | :------------- | :------------- | :---------------- |
| 普通派生函数 | 每次调用时计算 | 高 O(n)        | 简单计算/低频调用 |
| createMemo   | 依赖变更时计算 | 低 O(1) - 缓存 | 复杂计算/高频调用 |

# 状态提升

## 核心概念

将多个组件需要共享的状态提升到最近的共同祖先组件中，通过props向下传递数据和更新方法，实现跨组件状态同步。

## 基础实现

```jsx
import { createMemo, createSignal } from "solid-js";

// 父组件（状态管理者）
export default function App() {
  const [count, setCount] = createSignal(0);

  // 派生状态
  const doubleCount = createMemo(() => count() * 2);
  const squaredCount = createMemo(() => count() * count());

  return (
    <>
      <Counter count={count()} setCount={setCount} />
      <DisplayStats count={count()} double={doubleCount()} square={squaredCount()} />
    </>
  );
}

// 子组件（状态修改者）
function Counter(props) {
  const increment = () => props.setCount((c) => c + 1);
  return <button onClick={increment}>+1</button>;
}

// 子组件（状态展示者）
function DisplayStats(props) {
  return (
    <div>
      <div>当前值: {props.count}</div>
      <div>双倍值: {props.double}</div>
      <div>平方值: {props.square}</div>
    </div>
  );
}

```

## 关键原则

1. **单向数据流**：

   - 父组件通过props传递**只读**状态值
   - 同时传递setter函数允许子组件触发更新

2. **派生状态集中管理**：

   - 所有派生计算放在父组件
   - 使用 `createMemo` 优化性能

3. **类型安全（TS示例）**：

   ```ts
   interface CounterProps {
     count: number
     setCount: (updater: (prev: number) => number) => void
   }
   ```

**替代方案对比**

| 方案        | 优点       | 缺点             | 适用场景      |
| :---------- | :--------- | :--------------- | :------------ |
| 状态提升    | 简单直观   | 多层级传递繁琐   | 2-3层组件共享 |
| Context API | 跨层级共享 | 需要Provider包裹 | 深层组件树    |
| 状态管理库  | 解耦彻底   | 增加复杂度       | 大型应用      |

**最佳实践**

1. 将状态提升到足够高但不过度高的层级
2. 复杂派生状态使用createMemo缓存
3. 避免直接传递整个store，按需传递最小属性集
4. 对于频繁更新的状态，考虑使用Context优化







