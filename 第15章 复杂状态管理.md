# 概述

随着应用程序规模的增长，当涉及众多组件、复杂的用户交互以及可能需要与后端服务通信时，您会发现使用基础的状态管理方法将变得难以维护。

请看以下示例：

```tsx
import { For, createSignal, Show, createMemo } from "solid-js";

interface TaskProps {
  id: number;
  text: string;
  completed: boolean;
}
export default function App() {
  // -- Signals
  const [tasks, setTasks] = createSignal<TaskProps[]>([]);
  const [numberOfTasks, setNumberOfTasks] = createSignal(tasks.length);

  // -- Memos
  const completedTasks = createMemo(() => tasks().filter((task) => task.completed));

  // -- Refs
  let input!: HTMLInputElement;

  // -- Functions
  const addTask = (text) => {
    setTasks([...tasks(), { id: tasks().length, text, completed: false }]);
    setNumberOfTasks(numberOfTasks() + 1);
  };
  const toggleTask = (id) => {
    setTasks(tasks().map((task) => (task.id !== id ? task : { ...task, completed: !task.completed })));
  };

  // -- Render
  return (
    <>
      <h1>My list</h1>
      <span>You have {numberOfTasks()} task(s) today!</span>
      <div>
        <input ref={input} class="border" />
        <button
          onClick={(e) => {
            if (!input.value.trim()) return;
            addTask(input.value);
            input.value = "";
          }}
        >
          Add Task
        </button>
      </div>
      <For each={tasks()}>
        {(task) => {
          const { id, text } = task;
          console.log(`Creating ${text}`);
          return (
            <div>
              <input type="checkbox" checked={task.completed} onChange={[toggleTask, id]} />
              <span
                style={{
                  "text-decoration": task.completed ? "line-through" : "none",
                }}
              >
                {text}
              </span>
            </div>
          );
        }}
      </For>
    </>
  );
}

```

采用这种方式管理状态会面临若干挑战：

1. **代码冗余问题**

   需要为 `tasks`、`numberOfTasks` 等多个状态频繁调用 `createSignal`，同时还需使用 `createMemo` 计算 `completedTasks`，导致代码臃肿。每次状态更新都需要手动维护相关状态的同步，增加了应用状态不一致的风险。

2. **性能隐患**

   虽然Solid本身经过优化，但当前组件设计会导致频繁的重复计算（例如每次切换任务都会重新计算`completedTasks`）。随着状态依赖链的增长，这种设计模式可能对性能产生负面影响。

3. **逻辑耦合度过高**

   组件逻辑深度依赖 `numberOfTasks` 和 `completedTasks` 的当前状态，这种紧密耦合会降低代码可读性。当应用规模扩大时，新增依赖状态将要求在整个组件中进行多处更新，极易引入错误。

4. **组件复用障碍**

   这种集中式的状态管理使得将特定功能拆分为独立可复用组件变得困难，因为需要传递大量状态管理逻辑，破坏了组件的自治性。

# 引入 Store

通过使用 Store 重构这个任务列表，您将直观感受到 Store 如何提升代码的可读性和可维护性。

**重构优势说明**：

1. **状态集中管理**​

   将分散的 `createSignal`统一为结构化 Store

2. **自动派生状态**

   通过响应式系统自动计算 `completedTasks`等衍生数据

3. **逻辑解耦**

   业务逻辑与组件实现分离，提升可测试性

4. **性能优化**

   细粒度更新避免不必要的重复计算

## 创建 store

使用 Store 可以减少原示例中的 Signal 数量，具体实现如下：

```tsx
import { createStore } from "solid-js/store"

const App = () => {
  const [state, setState] = createStore({
    tasks: [],
    numberOfTasks: 0,
  })
}

export default App
```

通过使用 Store，您不再需要为 tasks、numberOfTasks 和 completedTasks 分别维护独立的 Signal。

## 访问状态值

创建 Store 后，您可以通过 `createStore`函数返回的第一个值直接访问状态：

```tsx
import { createStore } from "solid-js/store"

const App = () => {
  const [state, setState] = createStore({
    tasks: [],
    numberOfTasks: 0,
  })
  return (
    <>
      <h1>My Task List for Today</h1>
      <span>You have {state.numberOfTasks} task(s) for today!</span>
    </>
  )
}

export default App

```

通过  `state.numberOfTasks`，界面将显示存储在  `numberOfTasks` 属性中的值。

## 修改 Store 数据

当需要修改 Store 时，需使用 `createStore`函数返回的第二个元素。该元素允许您对 Store 进行修改，既能新增属性也能更新现有属性。但需要注意，由于 Store 中的属性是惰性创建的，若在组件函数体内直接设置属性而不创建追踪作用域，将不会触发值更新。要让 Signal 具备响应式更新能力，必须在追踪作用域内访问属性，例如使用 `createEffect`：

```tsx
// not reactive
setState("numberOfTasks", state.tasks.length)

// reactive
createEffect(() => {
  setState("numberOfTasks", state.tasks.length)
})
```

### 数组操作

要向数组（本例中的任务列表）添加元素，可以通过  `state.tasks.length` 指定下一个索引位置。通过组合定位 `tasks`键与目标索引，新任务将被添加到数组末尾。

```tsx
const addTask = (text) => {
  setState("tasks", state.tasks.length, {
    id: state.tasks.length,
    text,
    completed: false,
  })
}
```

Store 的设置器遵循路径语法：`setStore("key", value)`。在 `addTask`函数中，通过一下方式将新任务追加到 tasks 数组末尾，这就是该语法的一个实际应用示例。

```tsx
setState("tasks", state.tasks.length, { id: state.tasks.length, text, completed: false })
```

#### 使用 produce 进行状态变更

当需要执行多次 `setState`调用并修改多个属性时，可以使用 Solid 的 `produce`工具函数来简化代码并提升可读性。

例如任务切换功能：

```tsx
const toggleTask = (id) => {
  const currentCompletedStatus = state.tasks[id].completed
  setState(
    "tasks",
    (task) => task.id === id,
    "completed",
    !currentCompletedStatus
  )
}
```

可以使用 produce 简化：

```tsx
import { produce } from "solid-js/store"

const toggleTask = (id) => {
  setState(
    "tasks",
    (task) => task.id === id,
    produce((task) => {
      task.completed = !task.completed
    })
  )
}

// You can also rewrite the `addTask` function through produce
const addTask = (text) => {
  setState(
    "tasks",
    produce((task) => {
      task.push({ id: state.tasks.length, text, completed: false })
    })
  )
}
```

> **提示**：与 produce 一起工作的另一个好处是，它提供了一种在不进行多次 setStore 调用的前提下修改 store 的方法。
>
> ```tsx
> // without produce
> batch(() => {
>   setState(0, "text", "I'm updated text");
>   setState(0, "completed", true);
> });
> 
> // with produce
> setState(
>   0,
>   produce((task) => {
>     task.text = "I'm updated text";
>     task.completed = true;
>   })
> );
> 
> ```

## 更新后的示例

```tsx
import { For, createEffect, Show } from "solid-js";
import { createStore, produce } from "solid-js/store";

interface TaskProps {
  id: number;
  text: string;
  completed: boolean;
}

export default function App() {
  // -- Refs
  let input!: HTMLInputElement; // lets you target the input value

  // -- Stores
  const [state, setState] = createStore({
    tasks: [],
    numberOfTasks: 0,
  });

  // -- Actions
  const addTask = (text) => {
    setState("tasks", state.tasks.length, {
      id: state.tasks.length,
      text,
      completed: false,
    });
  };

  const toggleTask = (id) => {
    setState(
      "tasks",
      (task) => task.id === id,
      produce((task: TaskProps) => {
        task.completed = !task.completed;
      })
    );
  };

  // -- Effects
  createEffect(() => {
    setState("numberOfTasks", state.tasks.length);
  });

  // -- Render
  return (
    <>
      <div>
        <h1>My Task List for Today</h1>
        <span>You have {state.numberOfTasks} task(s) for today!</span>
      </div>
      <input ref={input} />
      <button
        onClick={(e) => {
          if (!input.value.trim()) return;
          addTask(input.value);
          input.value = "";
        }}
      >
        Add Task
      </button>
      <For each={state.tasks}>
        {(task) => {
          const { id, text } = task;
          return (
            <div>
              <input type="checkbox" checked={task.completed} onChange={() => toggleTask(task.id)} />
              <span>{text}</span>
            </div>
          );
        }}
      </For>
    </>
  );
}

```

# 状态共享

随着应用规模扩大和复杂度增加，组件间的状态共享会变得更具挑战性。将状态和函数从父组件逐层传递给子组件（尤其是跨越多层时），通常被称为"**属性穿透**"。这种模式会导致代码冗长难以维护，并使应用的数据流向难以追踪。为解决这个问题并构建更具扩展性和可维护性的代码库，Solid 提供了 Context 方案。

## 基础用法

1. 创建上下文

   首先需要创建带有默认值的上下文环境，该上下文可被任何子组件消费：

   ```ts
   import { createContext } from "solid-js"
   const TaskContext = createContext()
   ```

2. 提供共享值

   用 Provider 包裹组件树，并传入需要共享的值：

   ```tsx
   import { createStore } from "solid-js/store"
   
   const TaskApp = () => {
     const [state, setState] = createStore({
       tasks: [],
       numberOfTasks: 0,
     })
   
     return (
       <TaskContext.Provider value={{ state, setState }}>
         {/* 子组件树 */}
       </TaskContext.Provider>
     )
   }
   ```

3. 消费上下文

   在任何后代组件中通过 useContext 获取共享值：

   ```tsx
   import { useContext } from "solid-js"
   
   const TaskList = () => {
     const { state, setState } = useContext(TaskContext)
     // 现在可以使用共享状态和函数
   }
   ```

## 技术特性

- **精准更新**：只有实际使用上下文值的组件会响应更新
- **类型安全**：配合 TypeScript 可确保值类型一致性
- **嵌套支持**：支持多层 Provider 覆盖机制
- **性能优化**：避免不必要的组件重渲染

## 对比方案

| 方案          | 适用场景              | 优势         | 局限性               |
| :------------ | :-------------------- | :----------- | :------------------- |
| **Context**   | 中大型应用/深层组件树 | 避免属性钻取 | 需合理划分上下文范围 |
| **Props**     | 简单父子组件通信      | 直观明了     | 深层传递时代码冗长   |
| **全局Store** | 全应用状态管理        | 集中式管理   | 可能引起过度重渲染   |

Context 方案特别适合以下场景：

- 主题/语言等全局配置
- 用户认证状态
- 复杂表单状态管理
- 跨组件交互逻辑

通过合理划分上下文边界，可以构建出既保持组件独立性，又能高效共享状态的应用架构。