@See https://docs.solidjs.com/solid-router/

# 概述

Solid Router 是 Solid 的通用路由器，既支持客户端渲染，也支持服务端渲染。它的设计灵感来自 React Router 和 Ember Router，并结合了两者的范式。

路由器提供了一种根据浏览器中的 URL 来切换用户视图的方式。这使得「单页应用」能够模拟传统的多页面站点。要使用 Solid Router，你需要定义依赖于 URL（即「path」）的组件，这些组件称为 Routes，而路由器会负责在它们之间进行切换。

# 初体验

## 安装

安装依赖：

```shell
$ pnpm add @solidjs/router
```

## 组件路由

在 Solid Router 中，可以直接在应用的模板中使用 JSX 定义路由。这是定义路由最常见的方式。

要使用 JSX 定义路由，可以在 \<Router> 组件中为每个需要定义的路径添加一个 Route：

> `@/routes/tsx`

```tsx
import { Route, Router } from "@solidjs/router";
import Home from "@/pages/Home";
import Profile from "@/pages/Profile";
import About from "@/pages/About";

export default function AppRouter() {
  return (
    <Router>
      <Route path="/" component={Home} />
      <Route path="/about" component={About} />
      <Route path="/profile" component={Profile} />
    </Router>
  );
}
```

Route 组件接收一个 path 属性，用于匹配路径，以及一个 component 属性，用于传递当路径匹配时要渲染的组件（或元素）。在上面的示例中，当用户访问根路径 / 时，会渲染 Home 页面。

## 配置式路由

Solid Router 支持配置式路由，它提供了与组件式路由相同的功能。选择使用配置式路由还是组件式路由，主要取决于个人偏好。

要定义单个路由，可以将一个路由定义对象传递给 \<Router> 组件：

```tsx
import { Router } from "@solidjs/router";
import Home from "@/pages/Home";
import { lazy } from "solid-js";
const routes = [
  { path: "/", component: Home },
  { path: "/about", component: lazy(() => import("@/pages/About")) },
  { path: "/profile", component: lazy(() => import("@/pages/Profile")) },
];

export default function AppRouter() {
  return <Router>{routes}</Router>;
}
```

> 提示：在使用配置式路由时，最佳实践是使用 lazy 组件来异步加载组件。这有助于提升应用性能，因为只有在需要时才会加载对应的组件。

# 概念

## Navigation

在使用 Solid Router 时，你可以使用标准的 HTML \<a> 元素来触发软导航（soft navigation）。

除了这种方式外，Solid Router 还提供了其他路由导航选项：

- \<A> 组件
- useNavigate 原语
- redirect 函数

### \<A>

```tsx
import { A } from "@solidjs/router";
import type { JSX } from "solid-js";

export default function layouts(props: { children?: JSX.Element }) {
  return (
    <div>
      <nav class="flex gap-2">
        <A href="/" end={true}>Home</A>
        <A href="/about">About</A>
        <A href="/profile">Profile</A>
      </nav>
      <div>{props.children}</div>
    </div>
  );
}
```

\<A> 组件允许你根据链接的激活状态使用 activeClass 和 inactiveClass 属性来设置样式。当提供这些属性时，会将对应的 CSS 类应用到链接上；如果未提供，则使用默认的 active 和 inactive 类。

默认情况下，当当前路由匹配链接的 href 或其任意子路由时，链接会被视为激活。例如，href="/dashboard" 的链接在当前路由为 /dashboard、/dashboard/users 或 /dashboard/users/1/profile 时都会被视为激活。

要匹配精确路由，可以使用 end 属性。当其值为 true 时，只有当 href 与当前路由完全匹配时，链接才会被视为激活。这对于根路由链接（href="/"）非常有用，否则它可能会匹配所有路由。

### useNavigate

useNavigate 原语允许以编程方式导航到指定路由。

```tsx
import { useNavigate } from "@solidjs/router";

export default function App() {
  const navigate = useNavigate();

  return (
    <div>
      <button onClick={() => navigate("/profile", { replace: true })}>Jump</button>
    </div>
  );
}

```

### redirect

redirect 函数会返回一个 Response 对象，从而允许在 query 或 action 中导航到指定路由。

## 路径参数

路由中的参数用于捕获 URL 中的动态值。这对于创建更灵活、能够处理不同值的路由非常有用。

```tsx
<Route path="/users/:id" component={User} />
```

在这个例子中，:id 参数会捕获 URL 中 /users/ 后面的任意值。冒号 : 用于表示这是一个参数，id 是参数的名称。当 URL 匹配该路由时，会渲染 User 组件。

> **动画与过渡**
>
> 匹配相同路径的路由会被视为同一路由。如果需要强制重新渲染，可以将组件包裹在带 key 的 \<Show> 组件中：
>
> ```tsx
> <Show when={params.something} keyed>
>   <MyComponent />
> </Show>
> ```

### 访问参数

你可以使用 useParams 来获取路由参数捕获的值。

```tsx
import { useParams } from "@solidjs/router";
export default function User() {
  const params = useParams<{ id: string }>();
  return <div>User ID：{params.id}</div>; {/* Output: User ID: 123 */}
}
```

### 参数验证

每个路径参数都可以通过 Route 组件上的 MatchFilter 进行验证。与手动检查参数是否存在不同，使用 MatchFilter 可以确保参数符合正确的格式。

```tsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

const User = import("./pages/User");

const filters = {
  parent: ["mom", "dad"], // allow enum values
  id: /^\d+$/, // only allow numbers
  withHtmlExtension: (v: string) => v.length > 5 && v.endsWith(".html"), // we want an *.html extension
};

render(() => (
  <Router>
    <Route
      path="/users/:parent/:id/:withHtmlExtension"
      component={User}
      matchFilters={filters}
    />
  </Router>
), document.getElementById("app"));
```

在这里，matchFilter 属性会根据 filters 对象中定义的过滤器验证 parent、id 和 withHtmlExtension 参数。如果验证失败，该路由将不匹配，组件也不会被渲染。

在这个例子中，这意味着：

- `/users/mom/123/contact.html` 会匹配
- `/users/dad/456/about.html` 会匹配
- `/users/aunt/123/contact.html` 不会匹配，因为 `:parent` 不是 'mom' 或 'dad'
- `/users/mom/me/contact.html` 不会匹配，因为 `:id` 不是数字
- `/users/dad/123/contact` 不会匹配，因为 `:withHtmlExtension` 缺少 `.html`

### 可选参数

参数可以通过在参数名后添加 ? 来设为可选。

```tsx
<Route path="/users/:id?" component={User} />
```

通过这种设置，路由将同时匹配 /users 和 /users/123。

但需要注意，? 只会让路径中**最后一段参数**变为可选。因此，在可选参数之后的路径将不会被匹配。例如：

- /users ✅ 匹配
- /users/123 ✅ 匹配
- users/123/contact ❌ 不匹配

### 通配符路由

通配符路由可用于匹配路径中的任意数量的段。要创建通配符路由，请使用 * 加上参数名。

```tsx
<Route path="/users/*" component={User} />
```

使用星号 * 作为参数时，将匹配 /users 之后的任意数量的段。这包括 /users、/users/123、/users/123/contact 等。

如果你需要获取路径中的通配符段，可以为它们命名：

```tsx
<Route path="/users/*rest" component={User} />
```

在这种情况下，rest 将包含 /users/ 之后的剩余路径。

需要注意的是，通配符路由必须位于路径的末尾。如果你在末尾之前放置通配符路由，例如 /users/*rest/:id，将不会匹配到任何路由。

## 查询参数

查询参数用于通过查询字符串向路由传递数据。查询字符串是 URL 中位于 ? 之后的部分，用于以键值对的形式向路由传递数据。

在 Solid Router 中，可以使用 useSearchParams 来访问这些查询参数。该原语会返回一个元组，其中包含一个可响应对象（用于读取当前的搜索参数）以及一个用于更新它们的函数。

```tsx
import { useSearchParams } from "@solidjs/router";

export const App = () => {
  const [searchParams, setSearchParams] = useSearchParams();

  return (
    <div>
      <span>Username: {searchParams.username}</span>
      <input
        type="text"
        onChange={(e) => {
          e.preventDefault();
          setSearchParams({ username: e.target.value });
        }}
      />
    </div>
  );
};
```

在这个例子中，getter（即 searchParams）用于读取当前的搜索参数。

而 setSearchParams 则作为 setter，接收一个对象，其键值会被合并到当前的查询参数中。

### 多个查询参数

由于 setSearchParams 接收一个对象，因此你可以一次传入多个键值对来同时更新多个搜索参数。

```tsx
setSearchParams({
  username: "john",
  page: 1,
});
```

> 空值或 null 值
>
> 如果搜索参数的键对应的值为 undefined、null 或空字符串 ("")，它将会从查询字符串中被移除。

### 访问查询字符串

如果你需要直接访问查询字符串，可以使用 useLocation 原语：

```tsx
import { useLocation } from "@solidjs/router";

export const App = () => {
  const location = useLocation();

  return (
    <div>
      <span>Query String: {location.search}</span>
    </div>
  );
};
```

## 全匹配路由 404

全匹配路由用于匹配应用中未匹配到的任何 URL。这在显示 404 页面或在用户输入无效 URL 时重定向到特定路由时非常有用。

要创建全匹配路由，请在路由列表的末尾添加一个路径为星号 * 的路由。你也可以为参数命名，以访问未匹配的 URL 部分。

```tsx
import { Router, Route } from "@solidjs/router";

import Home from "./Home";
import About from "./About";
import NotFound from "./NotFound";

const App = () => (
  <Router>
    <Route path="/home" component={Home} />
    <Route path="/about" component={About} />
    <Route path="*404" component={NotFound} />
  </Router>
);
```

现在，如果用户访问的 URL 不匹配 /home 或 /about，将会渲染 NotFound 组件。

## 嵌套路由

嵌套路由用于在应用中创建路由层级结构。这对于在多个页面之间保持一致的布局，或创建相互关联的页面关系非常有用。

在 Solid Router 中，以下两种路由定义方式会产生相同的结果：

```tsx
<Route path="/users/:id" component={User} />

// is equivalent to

<Route path="/users">
  <Route path="/:id" component={User} />
</Route>
```

在这两种情况下，当 URL 为 /users/:id 时，User 组件都会被渲染。

区别在于：第一种情况中，/users/:id 是唯一的路由；而第二种情况中，/users 也是一个独立的路由。

### 限制

在嵌套路由中，只有最内层的 Route 组件会成为独立路由。例如，即使父路由也指定了组件，只有最内层的路由才会真正成为它自己的路由。

```tsx
<Route path="/users" component={Users}>
  <Route path="/:id" component={User} />
</Route>
```

要让父路由也成为独立路由，必须单独进行指定。这可以通过同时明确定义父路由和嵌套路由来实现：

```tsx
<Route path="/users" component={Users} />
<Route path="/users/:id" component={User} />
```

另一种实现相同效果的方法是嵌套路由，同时通过使用空路径明确指定父路由，然后再定义嵌套路由：

```tsx
<Route path="/users">
  <Route path="/" component={Users} />
  <Route path="/:id" component={User} />
</Route>
```

在这两种情况下，当 URL 为 /users 时，会渲染 Users 组件；当 URL 为 /users/:id 时，会渲染 User 组件。

### 基于配置的嵌套

在使用基于配置的路由时，可以通过将路由定义传入父路由对象的 children 属性来实现嵌套：

```tsx
import { render } from "solid-js/web";
import { Router } from "@solidjs/router";

const routes = {
  path: "/",
  component: lazy(() => import("/routes/index.js")),
  children: [
    {
      path: "/users",
      component: lazy(() => import("/routes/users.js")),
      children: [
        {
          path: "/:id",
          component: lazy(() => import("/routes/user.js")),
        },
      ],
    },
  ],
};

render(() => <Router>{routes}</Router>, document.getElementById("app"));
```

在此示例中，当导航到 /users/:id 时，会渲染 User 组件；同样地，当导航到 /users 时，会渲染 Users 组件。

## 布局

为了在应用的各个页面中保持一致性，可以使用布局（Layouts）。

布局是包裹路由内容的组件，可用于为所有页面或应用的特定部分定义统一的结构。

### 根布局

根级布局作为容器，包裹应用中的所有路由。要定义根级布局，可以将布局组件传递给 Router 组件的 root 属性：

```tsx
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

import Home from "./pages/Home";

const Layout = (props) => {
    return (
        <>
            <header>Header</header>
            {props.children}
            <footer>Footer</footer>
        </>
    );
};

render(
    () => (
        <Router root={Layout}>
            <Route path="/" component={Home} />
            <Route path="/hello-world" component={() => <div>Hello world!</div>} />
        </Router>
    ),
    document.getElementById("app")
);
```

在根级布局中，props.children 会被替换为当前路由的内容。这意味着“Header”和“Footer”会显示在每个页面上，而它们之间的内容会根据当前路由变化。例如，当路由为 /hello-world 时，你会在头部和底部之间看到文本 “Hello world!”。

### 嵌套布局

当你希望为一组路由创建特定布局时，可以在布局组件中嵌套路由。这可以通过将 props.children 传递给定义嵌套路由的组件来实现：

```tsx
function PageWrapper(props) {
  return (
    <div>
      <h1> We love our users! </h1>
      {props.children}
      <A href="/">Back Home</A>
    </div>
  );
}
```

虽然路由的配置保持不变，但路由的元素会出现在父组件中 props.children 声明的位置。要将 PageWrapper 用作布局，可以将其作为组件传递给父路由：

```tsx
<Router>
    <Route path="/users" component={PageWrapper}>
        <Route path="/" component={Users} />
        <Route path="/:id" component={User} />
    </Route>
</Router>
```

现在，当路由为 /users 时，Users 组件的内容会显示在 PageWrapper 组件内部。同样地，当导航到 /users/1 时，User 组件的内容也会显示在 PageWrapper 组件内部。

## 替代路由器

虽然默认路由器使用浏览器的 location.pathname 来确定当前路由，但你可以使用替代路由器来改变这种行为，包括：

- Hash 模式：使用 URL 的哈希部分来确定当前路由。
- Memory 模式：将路由历史保存在内存中，适用于测试场景。

### Hash 模式

Hash 模式路由使用 URL 的哈希部分来管理应用的状态和导航。与默认路由不同，URL 的哈希部分不会被服务器处理，这意味着它是纯客户端路由。

要使用 Hash 模式，只需将应用中的 \<Router /> 组件替换为 \<HashRouter />。

### Memory 模式

与默认路由和 Hash 模式不同，Memory 路由不会与浏览器的 URL 交互。这意味着虽然浏览器地址栏中的 URL 可能会变化，但路由不会真正导航到新路由。Memory 路由允许你在内存中控制路由的状态和历史记录，这在测试场景中非常有用。

要使用 Memory 模式，只需将应用中的 \<Router /> 组件替换为 \<MemoryRouter />。

## 动作 Actions

在开发应用时，经常需要根据用户的交互将新信息发送到服务器。Actions 是 Solid Router 提供的解决方案，用于处理这种需求。

### 什么是 Actions？

Actions 是异步处理函数，允许你向服务器提交数据并接收响应。它们是同构的（isomorphic），意味着可以根据需要在服务器或客户端运行。这种灵活性使 Actions 成为管理和跟踪数据提交的强大工具。



**Actions 的工作原理**

Actions 表示 HTML 表单的服务器端部分。它们通过 POST 请求处理提交，使你可以轻松使用 HTML 表单发送数据。

当用户执行某个操作（例如提交表单）时，数据会通过 action 发送到服务器进行处理。



**使用 Actions 的好处**

- 同构性（Isomorphic）：Actions 可以在服务器和客户端运行，你可以根据需求选择最佳执行环境来优化性能。
- 异步处理（Asynchronous processing）：Actions 异步处理数据提交，确保应用保持响应性。
- 简化数据处理（Simplified data handling）：使用 Actions 可以简化管理和跟踪数据提交的流程，降低应用的复杂性。

### 创建 Actions

要创建一个 Action，可以使用 @solidjs/router 包中的 action 函数。该函数接收一个异步函数作为参数，并返回一个可用于提交数据的新函数。

```tsx
import { action } from "@solidjs/router";

const echo = action(async (message: string) => {
  // Simulates an asynchronous operation, such as an API call
  await new Promise((resolve, reject) => setTimeout(resolve, 1000));
  console.log(message);
});
```

在此示例中，echo Action 模拟了一个带有 1 秒延迟的 fetch 调用，然后将消息记录到控制台。

echo Action 可以充当后端，但也可以替换为任何可以在客户端运行的 API。通常，路由 Actions 会与类似 fetch 或 GraphQL 的解决方案一起使用。

> 提示：在 SolidStart 应用中，建议使用 "use server" 指令，以充分利用服务器端功能。

#### 使用 Actions

要使用 Action，可以在组件内通过 useAction 调用它。该方法会返回一个函数，你可以传入必要的参数来触发该 Action。

```tsx
import { action, useAction } from "@solidjs/router";

const echo = action(async (message: string) => {
  await new Promise((resolve, reject) => setTimeout(resolve, 1000));
  console.log(message);
});

export function MyComponent() {
  const myEcho = useAction(echo);

  myEcho("Hello from Solid!");
}
```

在该组件中，useAction 用于获取对 echo Action 的引用。随后，该 Action 被调用并传入消息 "Hello from Solid!"，消息将在 1 秒延迟后被记录到控制台。

#### 从 Actions 返回数据

在许多情况下，提交数据后，服务器会返回一些数据。这可能是错误信息（如果操作失败）或成功操作的结果。Action 返回的任何内容都可以通过响应式的 action.result 属性访问，该值会在每次提交 Action 时更新。

要访问 Action 的结果，需要将该 Action 传递给 useSubmission：

```tsx
import { action, useAction, useSubmission } from "@solidjs/router";

const echo = action(async (message: string) => {
  await new Promise((resolve, reject) => setTimeout(resolve, 1000));
  return message;
});

export function MyComponent() {
  const myEcho = useAction(echo);
  const echoing = useSubmission(echo);

  myEcho("Hello from solid!");

  setTimeout(() => myEcho("This is a second submission!"), 1500);

  return <p>{echoing.result}</p>;
}
```

### 使用表单提交数据

在使用 Actions 提交数据时，推荐使用 HTML 表单。表单可以在 JavaScript 加载前使用，从而实现即时交互的应用。这也天然提供了可访问性优势，无需额外设计可能缺少这些功能的自定义 UI 库。

使用表单提交 Actions 时，传递给 Action 函数的第一个参数是一个 FormData 实例。要将 Actions 与表单配合使用，只需将 Action 传递给表单的 action 属性。这会创建渐进增强（progressively enhanced）的表单，即使在禁用 JavaScript 的情况下也能正常工作。

如果你的 Action 没有返回 Response，用户将停留在同一页面，响应会被重新触发。使用重定向（redirect）可以指示浏览器导航到新页面。

```tsx
import { action, redirect } from "@solidjs/router";

const isAdmin = action(async (formData: FormData) => {
  await new Promise((resolve, reject) => setTimeout(resolve, 1000));

  const username = formData.get("username");

  if (username === "admin") throw redirect("/admin");
  return new Error("Invalid username");
});

export function MyComponent() {

  return (
    <form action={isAdmin} method="post">
      <label for="username">Username:</label>
      <input type="text" name="username" />
      <input type="submit" value="submit" />
    </form>
  );
}
```

> 注意：如果你需要上传文件，请确保在 \<form> 元素中添加 enctype="multipart/form-data" 属性。

### 错误处理

与其抛出错误，不如从 Actions 中返回错误。这有助于与 useSubmission 一起使用时进行类型推导。在处理渐进增强（progressive enhancement）且客户端没有 JavaScript 的情况下，这一点尤为重要，因为错误可以被声明式地用于在服务器端渲染更新后的页面。

此外，在使用服务器端 Actions 时，最好在服务器端处理错误，以对错误信息进行清理和安全处理。

# 渲染模式

## 单页应用（Single Page Applications）

在部署使用客户端路由且不依赖服务端渲染（SSR）的应用时，需要确保对首页的重定向得到正确处理。这可以防止当访问不对应实际文件的 URL 时，CDN 或托管服务返回 “not found” 错误。

不同的托管服务有不同的处理方式。例如，Netlify 提供了一个 _redirects 文件，其内容可能如下：

```
/*   /index.html   200
```

而 Vercel 则需要在 vercel.json 中使用 rewrites 配置，例如：

```json
{
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/index.html"
    }
  ]
}
```

## 服务端渲染（Server-Side Rendering）

Solid Router 支持 Solid 的所有 SSR 功能。此外，它还内置了 Solid 的过渡效果，因此可以与 Suspense、Resources 和懒加载组件自由配合使用。

在使用 SSR 时，你可以选择直接使用静态路由（Static Router），或者通过传入 URL 让浏览器路由（Browser Router）在服务器端默认使用静态路由。

```tsx
import { isServer } from "solid-js/web";
import { Router } from "@solidjs/router";

<Router url={isServer ? req.url : ""} />;
```

Solid Router 还提供了一种方式，可以定义 preload 函数，使其与路由的 render-as-you-fetch 并行加载。

# 高级概念

## 懒加载（Lazy Loading）

懒加载允许你仅在需要时加载必要的资源。这在拥有大量路由和组件的大型应用中非常有用，可以减少初始加载时间。

在 Solid Router 中，你可以使用 Solid 提供的 lazy 函数来实现组件的懒加载：

```tsx
import { lazy } from "solid-js";
import { Router, Route } from "@solidjs/router";

const Home = lazy(() => import("./Home"));

const Users = lazy(() => import("./Users"));

const App = () => (
  <Router>
    <Route path="/" component={Home} />
    <Route path="/users" component={Users} />
  </Router>
);
```

在上面的示例中，Users 组件通过 lazy 函数实现懒加载。

lazy 函数接收一个返回 Promise 的函数，该 Promise 解析为你想要加载的组件。当路由匹配时，该组件会被加载并渲染。

