@See https://docs.solidjs.com/advanced-concepts/fine-grained-reactivity

# 概述

响应式机制能够自动响应数据变化，无需手动更新用户界面（UI）。通过将UI元素与底层数据相连接，更新过程实现了自动化。在细粒度响应式系统中，应用程序能够进行高度精准的定向更新。

这一点可以通过Solid和React的对比来体现。在Solid中，更新仅针对需要变更的具体属性，避免了更广泛且有时不必要的更新。相比之下，React会因单个属性的变化而重新执行整个组件，这种方式效率较低。

得益于细粒度响应式系统，不必要的重新计算得以避免。通过仅定位应用程序中发生变更的部分，用户体验变得更加流畅和优化。

# 响应式基础单元

Solid 的响应式系统包含两大核心要素：**信号（signals）**和**观察者（observers）**。这些基础单元构成了更高级的响应式特性：

- Stores

  本质上是代理对象，在底层自动创建、读取和写入信号

- Memos

  类似副作用（effects），但会返回信号并通过缓存优化计算

  虽然更新逻辑与副作用相似，但更专注于计算优化

- Resources

  在 memos 基础上发展而来，将异步网络请求转换为同步信号

  使请求结果可以直接嵌入信号系统

- 渲染副作用（Render effects）

  一种特殊类型的副作用，会立即执行

  专为管理渲染流程而设计

注：这些基础单元共同构成了 Solid 细粒度响应式的核心机制

## 理解 Signals

Signals 类似于可变变量，可以指向当前值并在未来指向另一个值。它们由两个主要函数组成：

1. **Getter**：读取 signal 当前值的方法
2. **Setter**：修改或更新 signal 值的方法

在 Solid 中，可以使用 `createSignal`函数创建一个 signal。这个函数以数组的形式返回 getter 和 setter：

```tsx
import { createSignal } from "solid-js";

// 创建一个初始值为 1 的 signal
const [count, setCount] = createSignal(1);

// 使用 getter 读取当前值
console.log(count()); // 输出 "1"

// 使用 setter 更新值
setCount(0); // 将 count 改为 0

// 再次读取
console.log(count()); // 输出 "0"
```

在这个例子中：

- `count` 是 getter 函数
- `setCount` 是 setter 函数

注：这种设计模式使得状态管理既明确又高效

## 副作用 Effects

副作用是响应信号变化的自动化函数，当依赖的信号值发生改变时自动执行。

```tsx
import { createSignal, createEffect } from "solid-js";

// 创建信号
const [count, setCount] = createSignal(0);

// 注册副作用
createEffect(() => {
  console.log("当前计数:", count()); 
  // 每当count变化时自动执行
});
```

关键特性：

1. **自动依赖追踪**：自动检测函数内使用的信号
2. **即时响应**：信号变化后立即触发
3. **清理机制**：支持返回清理函数

生命周期示例：

```tsx
import { createEffect, createSignal, Show } from "solid-js";

export default function App() {
  const [count, setCount] = createSignal(0);
  createEffect((prevCount) => {
    const current = count();
    if (prevCount) {
      console.log(`计数从 ${prevCount} 变为 ${current}`);
    }
    return current; // 返回值将作为下次执行的参数
  });
  return (
    <div>
      <button onclick={() => setCount((prev) => prev + 1)}>increment</button>
    </div>
  );
}
```

> **注意**：
>
> 1. 避免在副作用中直接修改依赖的信号
> 2. 副作用默认会立即执行一次
> 3. 适用于DOM操作、网络请求等副作用场景

注：与React的useEffect不同，Solid的createEffect采用同步执行模式

# 实现响应式系统

## 核心架构

我们将基于观察者模式构建一个简易响应式系统，包含两个核心功能：

1. **信号（Signal）**：存储值并维护订阅者列表
2. **副作用（Effect）**：注册回调函数并建立依赖关系

## `createSignal` 实现

```js
function createSignal(initialValue) {
  let value = initialValue;
  const subscribers = new Set(); // 订阅者集合

  // Getter函数
  function getter() {
    if (currentSubscriber) {
      subscribers.add(currentSubscriber); // 收集依赖
    }
    return value;
  }

  // Setter函数
  function setter(newValue) {
    if (value === newValue) return; // 值未变化时不触发更新
    value = newValue;
    subscribers.forEach(sub => sub()); // 通知所有订阅者
  }

  return [getter, setter];
}
```

## `createEffect` 实现

```js
let currentSubscriber = null; // 当前正在执行的副作用

function createEffect(fn) {
  const prevSubscriber = currentSubscriber;
  currentSubscriber = fn;
  fn(); // 执行时会收集依赖
  currentSubscriber = prevSubscriber; // 恢复上一个订阅者（处理嵌套effect）
}
```

## 响应式系统验证

```js
const [count, setCount] = createSignal(0);

createEffect(() => {
  console.log("当前计数: " + count());
});

// 每秒自动递增
setInterval(() => {
  setCount(count() + 1);
}, 1000);
```

## 核心机制说明

1. **依赖收集**
   - 当effect执行时，会设置`currentSubscriber`为当前effect
   - 在signal的getter中，将`currentSubscriber`添加到订阅列表
2. **更新传播**
   - 当signal值变化时，遍历执行所有订阅的effect
   - 通过`value === newValue`检查避免不必要的更新
3. **嵌套 effect 支持**
   - 通过保存/恢复`prevSubscriber`实现嵌套effect的正确依赖收集

注：这是响应式系统的核心实现原理，实际框架会进行更多优化

# 响应式系统生命周期管理

在响应式系统中，各种元素（通常称为"节点"）相互连接。这些节点可以是信号（signals）、副作用（effects）或其他响应式基础单元，它们作为独立单元共同构成了系统的响应式行为。

当某个节点发生变化时，系统会重新评估与该节点相连的部分。这可能导致这些连接的更新、新增或移除，从而影响系统的整体行为。

现在，考虑一个条件影响数据计算的场景：

```jsx
// Temperature.jsx
console.log("1. Initialize");
const [temperature, setTemperature] = createSignal(72);
const [unit, setUnit] = createSignal("Fahrenheit");
const [displayTemp, setDisplayTemp] = createSignal(true);

const displayTemperature = createMemo(() => {
  if (!displayTemp()) return "Temperature display is off";
  return `${temperature()} degrees ${unit()}`;
});

createEffect(() => console.log("Current temperature is", displayTemperature()));

console.log("2. Turn off displayTemp");
setDisplayTemp(false);

console.log("3. Change unit");
setUnit("Celsius");

console.log("4. Turn on displayTemp");
setDisplayTemp(true);
```

在这个示例中，`createMemo`原语用于缓存计算结果状态。这意味着如果其依赖项保持不变，就不需要重新运行计算。

`displayTemperature`memo 基于 `displayTemp`的值设置了提前返回条件。当 `displayTemp`为 false 时，memo 会返回"Temperature display is off"的消息，因此不会追踪 `temperature`和 `unit`。

然而，如果在 `displayTemp`为 false 时更改 `unit`，由于 memo 当前的依赖项（在本例中是 `displayTemp`）没有发生变化，因此不会触发 effect。

## 同步追踪机制

上述响应式系统以同步方式运行，这种运行方式影响着副作用及其依赖项的追踪机制。具体表现为：系统会先注册订阅者，然后执行副作用函数，最后注销订阅者——整个过程都是线性同步执行的。

请看以下示例：

```js
createEffect(() => {
  setTimeout(() => {
    console.log(count());
  }, 1000);
});
```

在这个示例中，`createEffect` 函数启动了一个延迟1秒执行的 `setTimeout`。由于系统是同步运行的，它不会等待这个异步操作完成。当 `setTimeout`中的 `count()` 被触发时，全局作用域中已不存在注册的订阅者。因此，这个 `count` 信号不会将回调函数添加为订阅者，从而导致无法追踪 `count` 的变化。

## 异步处理方案

虽然基础响应式系统采用同步机制，但Solid等框架提供了高级特性来处理异步场景。例如，`on`函数允许手动指定副作用的依赖项，这对于确保异步操作正确接入响应式系统尤为重要。

Solid还引入了**Resource**这一概念来管理异步操作。作为专用的响应式单元，Resource能将网络请求等异步操作转化为同步信号，使操作结果可嵌入信号系统。该机制能追踪异步操作及其状态，在操作完成或状态变更时保持UI同步更新。

在处理涉及多个异步操作、且完成状态可能影响响应式系统不同部分的复杂场景时，Resource尤为实用。通过集成Resource，开发者能确保依赖项被正确追踪，同时维持UI与底层异步数据的实时一致性。

### 手动依赖声明

```js
on(count, () => {
  setTimeout(() => console.log(count()), 1000);
});
```

### Resource 特性

```js
const [data] = createResource(fetchData);
createEffect(() => {
  console.log(data()); // 自动处理异步状态
});
```

### 关键特性对比

| 特性     | 同步效果 | 异步解决方案  |
| :------- | :------- | :------------ |
| 依赖收集 | 立即执行 | `on`手动声明  |
| 状态更新 | 即时触发 | Resource 包装 |
| 生命周期 | 线性执行 | 支持挂起/恢复 |

注：Solid通过Resource将异步操作转换为同步信号，保持响应式一致性