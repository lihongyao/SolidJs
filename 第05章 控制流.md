# 条件渲染

条件渲染是指根据特定条件来展示不同的 UI 元素。这是在 UI 开发中常见的模式，通常用来根据用户输入、数据或其他条件来显示或隐藏元素。

Solid 提供了专门的组件，用于更直接、更清晰地处理条件渲染。

## Show

`<Show>` 会在条件判断为 true 时渲染其子元素。它的作用类似于 JavaScript 中的三元运算符，通过在 JSX 中使用逻辑控制来决定渲染内容。

`<Show>`  提供了一个 when 属性，用来判断是否渲染子元素。当依赖的 state 或 props 发生变化时，这个属性会被重新计算。它既可以是一个布尔值，也可以是一个返回布尔值的函数。

```html
import { Show } from "solid-js"

<Show when={data.loading}>
  <div>Loading...</div>
</Show>
```

`<Show>`  提供了 fallback 属性，用来指定当条件为 false 时要渲染的内容。这个属性可以返回一个 JSX 元素。

```html
import { Show } from "solid-js"

<Show when={!data.loading} fallback={<div>Loading...</div>}>
  <h1>Hi, I am {data().name}.</h1>
</Show>
```

如果有多个条件需要处理，可以嵌套使用 `<Show>` 来分别处理每个条件。

```tsx
import { Show } from "solid-js"

<Show when={data.loading}>
  <div>Loading...</div>
  <Show when={data.error}>
    <div>Error: {data.error}</div>
  </Show>
</Show>
```

## Switch & Match

当有多个条件需要处理时，使用嵌套的 \<Show> 组件会让逻辑流程变得难以管理。为此，Solid 提供了 \<Switch> 和 \<Match> 组件。

类似于 JavaScript 的 switch/case 结构，\<Switch> 会包裹多个 \<Match> 组件，以便依次对每个条件进行判断。第一个判断结果为 true 的 \<Match> 组件会渲染其子元素，其余的会被忽略。

```html
import { Switch, Match } from "solid-js"

<Switch>
  <Match when={condition1}>
    <p>Outcome 1</p>
  </Match>
  <Match when={condition2}>
    <p>Outcome 2</p>
  </Match>
</Switch>
```

和 \<Show> 类似，每个 \<Match> 组件都有一个 when 属性，用来判断是否渲染其子元素。

同时，\<Switch> 还可以接收一个可选的 fallback 属性，用来指定当所有 \<Match> 组件的判断结果都为 false 时要渲染的内容。

```html
import { Switch, Match } from "solid-js"

<Switch fallback={<p>Fallback content</p>}>
  <Match when={condition1}>
    <p>Outcome 1</p>
  </Match>
  <Match when={condition2}>
    <p>Outcome 2</p>
  </Match>
</Switch>
```

# 动态组件

\<Dynamic> 是 Solid 提供的一个组件，它可以根据数据动态渲染组件。

你可以将一个表示原生 HTML 元素的字符串，或者一个组件函数传递给 component 属性，然后再配合你提供的其他属性来渲染所选组件。

```tsx
import { createSignal, For } from "solid-js";
import { Dynamic } from "solid-js/web";

const RedDiv = () => <div style="color: red">Red</div>;
const GreenDiv = () => <div style="color: green">Green</div>;
const BlueDiv = () => <div style="color: blue">Blue</div>;

const options = {
  red: RedDiv,
  green: GreenDiv,
  blue: BlueDiv,
};

export default function App() {
  const [selected, setSelected] = createSignal("red");
  return (
    <>
      <select value={selected()} onInput={(e) => setSelected(e.currentTarget.value)}>
        <For each={Object.keys(options)}>
          {(color) => <option value={color}>{color}</option>}
        </For>
      </select>
      <Dynamic component={options[selected()]} />
    </>
  );
}
```

这个例子渲染了一个 \<select> 元素，允许你在三种颜色之间进行选择。一旦选择了颜色，\<Dynamic> 组件就会渲染所选颜色对应的组件或元素。

> **提示**：这个和 Vue 中的动态组件 `<component :is>` 有点类似。

与其他条件渲染方式相比，\<Dynamic> 可以让代码更简洁。例如，下面的代码渲染的结果与前面的例子相同：

```tsx
import { createSignal, Switch, Match, For } from "solid-js";

const RedDiv = () => <div style="color: red">Red</div>;
const GreenDiv = () => <div style="color: green">Green</div>;
const BlueDiv = () => <div style="color: blue">Blue</div>;

const options = {
  red: RedDiv,
  green: GreenDiv,
  blue: BlueDiv,
};
export default function App() {
  const [selected, setSelected] = createSignal("red");
  return (
    <>
      <select value={selected()} onInput={(e) => setSelected(e.currentTarget.value)}>
        <For each={Object.keys(options)}>
          {(color) => <option value={color}>{color}</option>}
        </For>
      </select>
      <Switch fallback={<BlueDiv />}>
        <Match when={selected() === "red"}>
          <RedDiv />
        </Match>
        <Match when={selected() === "green"}>
          <GreenDiv />
        </Match>
      </Switch>
    </>
  );
}
```

与冗长的 \<Switch> 和 \<Match> 语句相比，\<Dynamic> 提供了一种更简洁的方式来动态渲染组件。

## Props

在使用这些组件时，你可以通过将属性传递给 \<Dynamic> 组件来向正在渲染的组件传递 props。这样，这些属性就可以在渲染的组件中使用，类似于在 JSX 中向组件传递 props。

```tsx
import { Dynamic } from "solid-js/web"

function App() {
  return (
    <Dynamic component={someComponent} someProp="someValue" />
  )
}
```

# 列表渲染

列表渲染允许你根据一组数据（如数组或对象）生成多个元素，每个元素对应集合中的一项。

在处理动态数据时，Solid 提供了两种渲染列表的方式：\<For> 和 \<Index> 组件。这两个组件都可以帮助你遍历数据集合生成元素，但它们适用于不同的场景。

## \<For>

\<For> 是一个循环组件，可以根据数组或对象的内容渲染元素。该组件适用于复杂的数据结构，例如对象数组，这类列表的顺序和长度可能会频繁变化。

\<For> 唯一的属性是 each，通过它你可以指定要循环的数据集合。该属性期望接收一个数组，但也可以接收已通过 Object.entries 或 Object.values 等工具转换成数组的对象。

```html
import { For } from "solid-js"

<For each={data()}>
  {(item, index) =>
    // rendering logic for each element
  }
</For>
```

在 \<For> 标签之间，组件需要一个回调函数，用来决定数据集合中的每一项应该如何渲染。这种结构类似于 JavaScript 中 map 方法的回调，提供了一个熟悉的模式。

该函数接收两个参数：

- `item`：表示当前正在渲染的数据集合中的项。
- `index`：表示当前项在集合中的索引。

你可以通过 item 和 index 来动态设置 JSX 元素的属性或内容。需要注意的是，index 是一个 signal，必须作为函数调用才能获取其值。

```tsx
<For each={data()}>
  {(item, index) => (
    <li
      style={{
        color: index() % 2 === 0 ? "red" : "blue"
      }}
    >
      {item.name}
    </li>
  )}
</For>
```

## \<Index>

\<Index> 与 \<For> 类似，也是一个循环组件，可以根据数组或对象的内容渲染元素。然而，当列表的顺序和长度保持稳定，但内容可能频繁变化时，\<Index> 是更好的选择，因为它会导致更少的重新渲染。

```html
import { Index } from "solid-js"

<Index each={data()}>
  {(item, index) => (
    // rendering logic for each element
  )}
</Index>
```

与 \<For> 组件类似，\<Index> 接受一个名为 each 的属性，用于传入你希望循环的结构。

在 \<For> 中，index 是一个 signal，而在 \<Index> 中，index 是固定的。这是因为 \<Index> 更关注数组中元素的索引。因此，item 是一个 signal，允许每个索引处的内容发生变化而不触发重新渲染，同时索引保持不变。

```html
import { Index } from "solid-js"

<Index each={data()}>
  {(item, index) => (
    <li>
      {item().name} - {item().completed}
    </li>
  )}
</Index>
```

## \<Index> vs. \<For>

\<For> 适用于列表的顺序和长度可能会频繁变化的场景。当 \<For> 中的列表值发生变化时，整个列表会被重新渲染。然而，如果数组发生变化，例如某个元素位置发生移动，\<For> 会通过移动对应的 DOM 节点并更新索引来处理。

而 \<Index> 适用于列表的顺序和长度保持稳定，但内容可能频繁变化的场景。当 \<Index> 中的列表值发生变化时，只有指定索引处的内容会被更新。

**何时适用 \<For> 🤔**

在不需要 signals、嵌套循环或动态列表的情况下，\<For> 是最佳选择。例如，在创建包含静态元素（如链接列表）的列表时，\<For> 是最合适的使用选项。这是因为它只会修改列表中元素的索引，而不会重新渲染整个列表。

```tsx
import { createSignal, For } from "solid-js"

function StringList() {
  const [items, setItems] = createSignal(["Item 1", "Item 2", "Item 3"])

  return (
    <ul>
      <input
        type="text"
        onInput={(e) => {
          // add the new item to the list
        }}
      />
      <For each={items()}>
        {(item, index) => (
          <li>
            {item} - {index()}
          </li>
        )}
      </For>
    </ul>
  )
}
```

如果你正在处理 signal、JavaScript 原始类型（如字符串和数字）或输入框，使用 \<Index> 会更合适。

如果使用 \<For>，当某个值发生变化时，即使列表长度没有改变，整个列表也会被重新渲染。而 \<Index> 则只会更新指定索引处的内容，其余列表保持不变。

```tsx
import { createSignal, Index } from "solid-js"

function FormList() {
  const [inputs, setInputs] = createSignal(['input1','input2','input3'])
  return(
    <form>
      <Index each={inputs()}>
        {(input, index) => (
          <input
            type="text"
            value={input()}
            onInput={(e) => {
              // update the input value
            }}
          />
        )}
      </Index>
    </form>
  )
}
```

# Portal

当一个元素需要在正常文档流之外渲染时，内容堆叠和 z-index 相关的问题可能会影响应用的预期效果或外观。\<Portal> 可以通过将元素放到文档的其他位置来解决这个问题，使元素能够按预期进行渲染。

```html
import { Portal } from "solid-js/web"

<Portal>
  <div class="popup">...</div>
</Portal>
```

嵌套在\<Portal> 内的内容默认会渲染并定位在文档 body 的末尾。

![](./imgs/poral_render.jpeg)

可以通过向 \<Portal> 传递 mount 属性来更改这一行为。mount 属性接收一个 DOM 节点，该节点将作为 portal 内容的挂载点。

```html
import { Portal } from "solid-js/web"

<Portal mount={document.querySelector("main")}>
  <div class="popup">...</div>
</Portal>
```

在某些情况下，使用 \<Portal> 特别有用，例如信息弹窗可能会因为父元素的 overflow 设置而被裁剪或遮挡。通过将元素放到父元素之外，它就不再受父元素 overflow 设置的限制。这为用户提供了更好的体验，因为内容不会再被遮挡。

> 注意：\<Portal> 会将内容渲染在包裹元素中，除非特别指定挂载到 document.head。这样做的目的是让事件根据组件层级而不是元素层级在 Portal 中传播。默认情况下，子元素会被包裹在一个 \<div> 中。

# 错误边界

默认情况下，如果应用的某部分在渲染过程中抛出错误，整个应用可能会崩溃，导致 Solid 将其 UI 从屏幕上移除。错误边界提供了一种捕获这些错误并防止整个应用崩溃的方法。

\<ErrorBoundary> 组件用于创建错误边界。它可以捕获在子元素渲染或更新过程中发生的任何错误。但需要注意的是，渲染过程之外发生的错误，例如事件处理函数中或 setTimeout 后的错误，是无法被错误边界捕获的。

可以使用 fallback 属性在发生错误时显示用户友好的错误信息或提示。如果传递一个函数给 fallback，该函数会接收错误对象和一个 reset 函数。reset 函数会强制 \<ErrorBoundary> 重新渲染其子元素并重置错误状态，为用户提供从错误中恢复的方式。

```tsx
import { ErrorBoundary } from "solid-js";
import { Header, ErrorProne } from "./components";

export default function App() {
  return (
    <div>
      <Header />
      <ErrorBoundary
        fallback={(error, reset) => (
          <div>
            <p>Something went wrong: {error.message}</p>
            <button onClick={reset}>Try Again</button>
          </div>
        )}
      >
        <ErrorProne />
      </ErrorBoundary>
    </div>
  );
}
```

在这个例子中，当 ErrorProne 组件抛出错误时，\<ErrorBoundary> 会捕获该错误，防止其影响应用的其他部分。取而代之的是，它会显示传递给 fallback 属性的错误信息。

